Problem: Reverse a singly linked list.

Problem Explanation:
Given a singly linked list, you need to reverse it so that the first element becomes the last, and the last element becomes the first.

Approach:

1.Initialize three pointers: prev, curr, and next.
2.Traverse through the list while reversing the next pointer of each node.
3.Update the prev pointer to the current node, and curr pointer to the next node.
4.Finally, update the head of the linked list to the last node.

Code:
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head):
    prev = None
    curr = head
    
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
        
    return prev

# Helper function to print the linked list
def print_linked_list(head):
    while head:
        print(head.val, end=" -> ")
        head = head.next
    print("None")

# Example
head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
print("Original List:")
print_linked_list(head)

reversed_head = reverse_linked_list(head)
print("Reversed List:")
print_linked_list(reversed_head)

Explanation:

The approach uses a simple iterative method with three pointers (prev, curr, next_node) to reverse the linked list in O(n) time complexity.
The space complexity is O(1), as the reversal is done in place.
